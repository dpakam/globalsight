<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE deploy-service PUBLIC '-//Pramati Technologies //DTD Pramati Deploy Service 3.5//EN' 'http://www.pramati.com/dtd/pramati-deploy-service.dtd'>

<deploy-service> 
  <!--
      This file represents the configuration for DeployService which deploys and manages
      J2EE applications on Pramati Server.The configuration mentioned here is typically
      applied server wide, for all applications, unless explicitly specified for an application.
      Some of the configuration here can be overridden  by commandline parameters
      during deployment/start of applications.

   --> 
  <!--
      The Auto Deploy feature deploys applications automatically from the configured
      directory.To deploy an application, just drag and drop an archive into the
      directory.The AutoDeployer periodically checks for new file additions and deploys the
      newly added files onto the server.The poll interval is also configurable.
  --> 
  <auto-deploy> 
    <dir>$NODE_DIR/archives/autodeploy</dir> 
    <poll-interval-seconds>5</poll-interval-seconds> 
  </auto-deploy> 
  <!--
       The validation tags define the validation behaviour of the DeployService.

       The DeployService provides for two types of validations

       1.Application Validation (app-archive-validation)- The Application components are
       validated against the Application provider's responsibilities in the specification and
       verified to be valid J2EE components.This process has no dependency on
       the server environment and can also be used as a standalone process.However, it
       is recommended the validation is done when deploying for the first time.

       2.App Start Validation(app-start-validation) - This validates the server environment for an application.
       all resources required for the application are validated, any potential namespace clashes
       due to the start of this application are verified.

       DTD validation is also performed during creation of DOM structure from DeploymentDescriptors.
       All validation flags can be controlled based on the application action i.e.
       turn on validation for deploy and turn it off for re-deploy and so on.
  --> 
  <validation> 
    <!-- tag to enable application validation
    {on-deploy - first deployment,on-redeploy - subsequent,on-start - every time the app starts} --> 
    <app-archive-validation on-deploy="true" on-redeploy="true" on-start="false" /> 
    <!-- tag to enable dtd validation
    {on-deploy - first deployment,on-redeploy - subsequent,on-start - every time the app starts} --> 
    <dtd-validation on-deploy="false" on-redeploy="false" on-start="false" /> 
    <!-- tag to enable app start validation
    {on-deploy - first deployment,on-redeploy - subsequent,on-start - every time the app starts} --> 
    <app-start-validation enabled="true"> 
      <rules> 
	<!-- checks exclusively for CMP beans where the mapping information is validated
            db-table-check checks for existence of the tables the beans are mapped against
            db-table-mapping-check checks for all CMP filed mapping
            --> 
	<db-table-check enabled="true" /> 
	<db-table-mapping-check enabled="true" /> 
      </rules> 
    </app-start-validation> 
  </validation> 
  <!--tag that indicates whether to use dynamic proxies for EJBs --> 
  <enable-proxies-for-ejb>false</enable-proxies-for-ejb> 
  <!-- tag for retaining generated java files during deployment for EJB components --> 
  <retain-generated-java-files>false</retain-generated-java-files> 
  <!-- tag for retaining files generated after deployment failure --> 
  <retain-files-on-deploy-failure>false</retain-files-on-deploy-failure> 
  <!--
        tags for compilation options
          Compilation can be done either

          1: In Memory - where an in memory compiler is used
          2: Out of process - where an external compiler is used

        This is launched as a separate process.In such a case the path to an external
        compiler like JIKES can be used.The JDK compiler is used by default
        The value for the use attribute can be "javac", "jikes" etc.
        The value for the path attribute should be the full path to the compiler executable
        E.g.
	    <external-compiler use="javac" path="C:\jdk1.3.101\bin\javac.exe" />
		    or
	    <external-compiler use="jikes" path="C:\Jikes\bin\jikes.exe" />
	
	If out of process compilation is enabled, compiler memory options can be specified under
	the <options> tag as property name-value pairs. The options currently supported are for
	the initial JVM heap size and the maximum JVM heap size. Both of these options have to be
	set for the memory options to work.
	E.g.
		<options>
			This property corresponds to the -J-Xms flag
			<property name="initial-heap-size-megabytes" value="120" />
			This property corresponds to the -J-Xmx flag			
			<property name="maximum-heap-size-megabytes" value="200" />
		</options>
    	--> 
  <compilation> 
    <out-of-process-compilation enabled="false"> 
      <!--external-compiler use="javac" path="C:\jdk1.3.101\bin\javac.exe" /--> 
      <!--options>
				<property name="initial-heap-size-megabytes" value="120" />
				<property name="maximum-heap-size-megabytes" value="200" />
			</options--> 
    </out-of-process-compilation> 
  </compilation> 
  <!--
        Classloading configuration :

          The default behavior that the DeployService provides is

            1)One ClassLoader per application
                      and
            2)ClassLoader used for the Web Components is the child classloader
              of the EJB/RAR components

          The One ClassLoader  per Application behavior can be modified using the below tags.
          The Deploy Service provides for ApplicationGroups where a group of applications
          share the same classloader. To enable groups the classloaders for multiple
          apps, this option has to be turned on, which means a CL would now be used for multiple
          apps.Any number of groups can then be declared (shown in comments).

          Abscence of any groups after enabling multiple application ClassLoader would mean a universal
          application group where all applications share the same ClassLoader
          Refer to documentation for ClassLoading configuration done at a per-application level.

  --> 
  <classloader-for-multiple-apps enabled="true"> 
    <!-- sample application group definition --> 
    <!-- application-group apps="abcd.ear,xyz.jar" --> 
    <!-- any app not in the list above, will get its own ClassLoader
        if no grps are specified, then 1 ClassLoader is used for all applications --> 
  </classloader-for-multiple-apps> 
  <!--
        The Deploy Service provides versioning for applications in the archives directory.
        The first version dir is created when the app is deployed for the first time.
        all subsequent versions are deployed onto different directories.
        information on the latest deployed version and the version to be used are maintained here.
        Any previous version can be started. Also a failed re-deployment would always mean there
        is a valid version to use.

        To disable maintaining multiple directories Versioning can be disabled.
    --> 
  <application-properties versioning-enabled="true"> 
    <application name="globalsight.ear">
      <version use="1" latest-version="1" />
    </application>
  </application-properties> 
  <!--
        Startup hooks are used to synchronize with server lifecycle events
        DeployService maintains such hooks.A class name entry below would mean that the
        class is to be used as a startup hook.Refer to the interface com.pramati.services.j2ee.spi.StartupHook and
        documentation for more details.
 --> 
  <startup-hooks> </startup-hooks> 
  <!--
        Application hooks are used to synchronize with application lifecycle events
        DeployService maintains such hooks. Each application can have it's own hook. The classname attribute is
        the class which implements the application hook interface. The async parameter specifies whether or not 
        to call the hook methods in a separate thread or not. Refer to the interface 
        com.pramati.services.j2ee.spi.ApplicationStateListener and documentation for more details.
 --> 
  <application-hooks> 
    <!--application-hook app-name="appName" async="true" class-name="className" /--> 
    <application-hook app-name="globalsight.ear" async="false" class-name="com.globalsight.util.j2ee.pramati.AmbassadorStartupShutdown" /> 
  </application-hooks> 
</deploy-service>

